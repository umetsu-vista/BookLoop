// ============================================================
// BookLoop v1.1 â€” å…¨ 12 é …ç›®ä¿®æ­£ å®Ÿè£…ã‚³ãƒ¼ãƒ‰
// ============================================================
//
// ã‚«ãƒ†ã‚´ãƒª A: å…±æœ‰ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ (ä¿®æ­£ #1â€“#3)
// ã‚«ãƒ†ã‚´ãƒª B: Drizzle ã‚¹ã‚­ãƒ¼ãƒ (ä¿®æ­£ #4â€“#5)
// ã‚«ãƒ†ã‚´ãƒª C: Service å±¤ã®è¨­è¨ˆ (ä¿®æ­£ #6â€“#12)
//
// ============================================================

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// A. å…±æœ‰ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ (packages/shared)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// ============================================================
// ä¿®æ­£ #1: generateId ã‚’ shared ã‹ã‚‰å‰Šé™¤ â†’ å„ç’°å¢ƒå›ºæœ‰ã®å®Ÿè£…ã¸
// ============================================================

// --- packages/shared/src/utils/id.ts (å‰Šé™¤) ---
// âŒ æ—§: export const generateId = () => crypto.randomUUID()
//    â†’ Node / Workers / React Native ã§ crypto.randomUUID ã®
//      Polyfill çŠ¶æ³ãŒç•°ãªã‚‹ãŸã‚ã€shared ã«ç½®ãã¹ãã§ã¯ãªã„

// --- apps/api/src/lib/id.ts (æ–°è¦) ---
// Workers ç’°å¢ƒ: Web Crypto API ãŒãƒã‚¤ãƒ†ã‚£ãƒ–ã§ä½¿ãˆã‚‹
export function generateId(): string {
  return crypto.randomUUID();
}

// --- apps/mobile/src/lib/id.ts (æ–°è¦) ---
// Expo / React Native ç’°å¢ƒ: expo-crypto ã‚’ä½¿ç”¨
// import * as Crypto from 'expo-crypto';
// export function generateId(): string {
//   return Crypto.randomUUID();
// }

// --- apps/web/src/lib/id.ts (æ–°è¦) ---
// Next.js (ãƒ–ãƒ©ã‚¦ã‚¶): Web Crypto API
// export function generateId(): string {
//   return crypto.randomUUID();
// }

// ============================================================
// ä¿®æ­£ #2: GET ã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã® z.number() â†’ z.coerce.number()
// ============================================================

// --- packages/shared/src/validators/common.ts ---
import { z } from "zod";

// ã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯å¸¸ã« string ã§å±ŠããŸã‚ z.coerce ã‚’ä½¿ã†
export const paginationSchema = z.object({
  cursor: z.string().optional(),
  limit: z.coerce.number().int().min(1).max(100).default(20),
});

export const yearMonthSchema = z.object({
  year: z.coerce.number().int().min(2020).max(2100),
  month: z.coerce.number().int().min(1).max(12),
});

// --- packages/shared/src/validators/bookshelf.ts ---
export const bookshelfQuerySchema = z.object({
  status: z
    .enum(["WANT_TO_READ", "READING", "FINISHED"])
    .optional(),
  sort: z
    .enum(["updated_at", "title", "author", "created_at"])
    .default("updated_at"),
  order: z.enum(["asc", "desc"]).default("desc"),
  cursor: z.string().optional(),
  limit: z.coerce.number().int().min(1).max(50).default(20), // â† coerce
});

// --- packages/shared/src/validators/session.ts ---
export const sessionListQuerySchema = z.object({
  bookId: z.string().optional(),
  cursor: z.string().optional(),
  limit: z.coerce.number().int().min(1).max(50).default(20), // â† coerce
});

export const manualSessionSchema = z.object({
  bookId: z.string().min(1),
  date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/),
  durationMin: z.coerce.number().int().min(1).max(480), // â† coerce
  pageStart: z.coerce.number().int().min(0).optional(),
  pageEnd: z.coerce.number().int().min(0).optional(),
  memo: z.string().max(2000).optional(),
});

// --- packages/shared/src/validators/stats.ts ---
export const weeklyStatsQuerySchema = z.object({
  date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/),
});

export const monthlyStatsQuerySchema = yearMonthSchema;

// ============================================================
// ä¿®æ­£ #3: SessionEndResult ã®å‹ãŒæ›–æ˜§ â†’ ãƒ¬ã‚¹ãƒãƒ³ã‚¹å°‚ç”¨å‹ã‚’æ–°è¨­
// ============================================================

// --- packages/shared/src/types/session.ts ---
export type SessionType = "TIMER" | "EXTERNAL" | "MANUAL";
export type ExternalApp = "KINDLE" | "KOBO" | "OTHER";

/** POST /sessions â†’ 201 */
export interface SessionStartResponse {
  id: string;
  bookId: string;
  sessionType: SessionType;
  externalApp: ExternalApp | null;
  startedAt: string;
  isActive: true;
}

/** POST /sessions/:id/end â†’ 200 */
export interface SessionEndResponse {
  session: CompletedSessionResponse;
  streak: StreakUpdateResponse;
  dailyLog: DailyLogResponse;
}

/** POST /sessions/manual â†’ 201 (same shape as end) */
export type ManualSessionResponse = SessionEndResponse;

/** POST /sessions/:id/pause â†’ 200 */
export interface SessionPauseResponse {
  sessionId: string;
  pauseId: string;
  pausedAt: string;
  isPaused: true;
}

/** POST /sessions/:id/resume â†’ 200 */
export interface SessionResumeResponse {
  sessionId: string;
  pauseId: string;
  resumedAt: string;
  pauseDurationSec: number;
  isPaused: false;
}

/** POST /streaks/freeze â†’ 200 */
export interface FreezeResponse {
  id: string;
  usedDate: string;
  remainingFreezes: number;
  currentStreak: number;
}

/** DELETE /sessions/:id â†’ 200 (ä¿®æ­£ #7 ã§è¿½åŠ ) */
export interface SessionDiscardResponse {
  discardedSessionId: string;
  dailyLog: DailyLogResponse | null; // å†é›†è¨ˆå¾Œã€‚ã‚»ãƒƒã‚·ãƒ§ãƒ³ 0 ä»¶ã®æ—¥ã¯ null
  streak: StreakUpdateResponse;
}

// â”€â”€ å…±é€šã‚µãƒ–å‹ â”€â”€

export interface CompletedSessionResponse {
  id: string;
  bookId: string;
  sessionType: SessionType;
  durationSec: number;
  pausedTotalSec: number;
  wallClockSec: number; // durationSec + pausedTotalSec
  pageStart: number | null;
  pageEnd: number | null;
  memo: string | null;
  localDate: string;
  startedAt: string;
  endedAt: string;
}

export interface StreakUpdateResponse {
  currentStreak: number;
  longestStreak: number;
  isNewRecord: boolean;
}

export interface DailyLogResponse {
  logDate: string;
  totalSeconds: number;
  sessionCount: number;
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// B. Drizzle ã‚¹ã‚­ãƒ¼ãƒ (apps/api/src/db)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// ============================================================
// ä¿®æ­£ #4: books.isbn UNIQUE + NULL ã®æŒ™å‹•ã‚’æ˜ç¤ºåŒ–
// ============================================================

// --- apps/api/src/db/schema.ts (books ãƒ†ãƒ¼ãƒ–ãƒ«éƒ¨åˆ†) ---
import {
  sqliteTable, text, integer, index, uniqueIndex,
} from "drizzle-orm/sqlite-core";
import { sql } from "drizzle-orm";

export const books = sqliteTable(
  "books",
  {
    id: text("id")
      .primaryKey()
      .$defaultFn(() => crypto.randomUUID()),
    // ğŸ”„ v1.1: ISBN ãŒ NULL ã®æ‰‹å‹•ç™»éŒ²æ›¸ç±ã«ã¤ã„ã¦
    // SQLite ã® UNIQUE åˆ¶ç´„ã¯ NULL ã‚’ã€Œã™ã¹ã¦ç•°ãªã‚‹å€¤ã€ã¨ã—ã¦æ‰±ã†ã€‚
    // ã¤ã¾ã‚Š isbn = NULL ã®ãƒ¬ã‚³ãƒ¼ãƒ‰ã¯ä½•ä»¶ã‚ã£ã¦ã‚‚åˆ¶ç´„é•åã«ãªã‚‰ãªã„ã€‚
    // â†’ æ‰‹å‹•ç™»éŒ²æ›¸ç±ã®é‡è¤‡é˜²æ­¢ã¯ã‚¢ãƒ—ãƒªå±¤ï¼ˆBookService.checkDuplicateï¼‰ã§å®Ÿè£…ã™ã‚‹ã€‚
    isbn: text("isbn").unique(),
    title: text("title").notNull(),
    author: text("author"),
    publisher: text("publisher"),
    coverUrl: text("cover_url"),
    totalPages: integer("total_pages"),
    description: text("description"),
    genre: text("genre").default("OTHER"),
    publishedAt: text("published_at"),
    source: text("source").default("MANUAL"),
    // ğŸ”„ v1.1 (#8): ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ç”¨
    fetchedAt: text("fetched_at"),
    createdAt: text("created_at")
      .notNull()
      .default(sql`(datetime('now'))`),
  },
  (table) => ({
    isbnIdx: uniqueIndex("idx_books_isbn").on(table.isbn),
    titleIdx: index("idx_books_title").on(table.title),
  })
);

// ============================================================
// ä¿®æ­£ #5: ãƒ‘ãƒ¼ã‚·ãƒ£ãƒ«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒ Drizzle æœªå¯¾å¿œ â†’ æ‰‹å‹• SQL
// ============================================================

// --- apps/api/src/db/migrations/0001_partial_indexes.sql ---
/*
-- Drizzle ORM ã¯ WHERE ä»˜ãã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆãƒ‘ãƒ¼ã‚·ãƒ£ãƒ«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼‰ã‚’
-- ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãªã„ãŸã‚ã€æ‰‹å‹•ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã§ä½œæˆã™ã‚‹ã€‚
--
-- drizzle-kit ãŒè‡ªå‹•ç”Ÿæˆã™ã‚‹ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã¨ã¯åˆ¥ç®¡ç†ã€‚
-- ã‚¢ãƒ—ãƒªèµ·å‹•æ™‚ or CI ã§æ˜ç¤ºçš„ã«å®Ÿè¡Œã™ã‚‹ã€‚

-- ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚»ãƒƒã‚·ãƒ§ãƒ³æ¤œç´¢ã®é«˜é€ŸåŒ–
-- is_active = 1 ã®ãƒ¬ã‚³ãƒ¼ãƒ‰ã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚ãŸã‚Šæœ€å¤§ 1 ä»¶ãªã®ã§éå¸¸ã«å°ã•ã„
CREATE INDEX IF NOT EXISTS idx_sessions_user_active
  ON reading_sessions(user_id, is_active)
  WHERE is_active = 1;

-- æœªèª­æ›¸ç±ã®é«˜é€Ÿæ¤œç´¢
CREATE INDEX IF NOT EXISTS idx_user_books_reading
  ON user_books(user_id, status)
  WHERE status = 'READING';

-- æœªä½¿ç”¨ãƒ•ãƒªãƒ¼ã‚ºã®é«˜é€Ÿæ¤œç´¢ï¼ˆæœˆã”ã¨ã®æ®‹æ•°ãƒã‚§ãƒƒã‚¯ï¼‰
CREATE INDEX IF NOT EXISTS idx_freezes_user_month
  ON streak_freezes(user_id, used_date)
  WHERE used_date IS NOT NULL;
*/

// --- apps/api/src/db/migrate.ts ---
// import { readFileSync } from 'node:fs';
// Drizzle è‡ªå‹•ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å¾Œã«æ‰‹å‹• SQL ã‚’å®Ÿè¡Œ
export async function applyPartialIndexes(
  db: ReturnType<typeof import("drizzle-orm/libsql").drizzle>
) {
  const statements = [
    `CREATE INDEX IF NOT EXISTS idx_sessions_user_active
       ON reading_sessions(user_id, is_active) WHERE is_active = 1`,
    `CREATE INDEX IF NOT EXISTS idx_user_books_reading
       ON user_books(user_id, status) WHERE status = 'READING'`,
    `CREATE INDEX IF NOT EXISTS idx_freezes_user_month
       ON streak_freezes(user_id, used_date) WHERE used_date IS NOT NULL`,
  ];
  for (const stmt of statements) {
    await db.run(sql.raw(stmt));
  }
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// C. Service å±¤ã®è¨­è¨ˆ (apps/api/src)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// ============================================================
// ä¿®æ­£ #6: DI ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ•´ç† â†’ Service ãƒ•ã‚¡ã‚¯ãƒˆãƒª + ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢
// ============================================================

// --- apps/api/src/services/factory.ts ---
import type { LibSQLDatabase } from "drizzle-orm/libsql";
import type * as schema from "../db/schema";

type DB = LibSQLDatabase<typeof schema>;

// Service ã‚¯ãƒ©ã‚¹ç¾¤ï¼ˆç°¡ç•¥ç‰ˆ â€” å¾Œè¿°ã§å„ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ï¼‰
export class BookService {
  constructor(private db: DB) {}
  // ... ãƒ¡ã‚½ãƒƒãƒ‰ã¯å¾Œè¿°
}
export class BookshelfService {
  constructor(private db: DB) {}
}
export class SessionService {
  constructor(private db: DB) {}
}
export class StreakService {
  constructor(private db: DB) {}
}
export class StatsService {
  constructor(private db: DB) {}
}
export class NoteService {
  constructor(private db: DB) {}
}

export interface Services {
  book: BookService;
  bookshelf: BookshelfService;
  session: SessionService;
  streak: StreakService;
  stats: StatsService;
  note: NoteService;
}

/** ãƒªã‚¯ã‚¨ã‚¹ãƒˆã”ã¨ã« 1 å›ã ã‘å‘¼ã¶ã€‚å…¨ Service ãŒåŒä¸€ DB æ¥ç¶šã‚’å…±æœ‰ã€‚ */
export function createServices(db: DB): Services {
  return {
    book: new BookService(db),
    bookshelf: new BookshelfService(db),
    session: new SessionService(db),
    streak: new StreakService(db),
    stats: new StatsService(db),
    note: new NoteService(db),
  };
}

// --- apps/api/src/middleware/services.ts ---
import { createMiddleware } from "hono/factory";
import { createServices } from "../services/factory";
// import { drizzle } from "drizzle-orm/libsql";

/**
 * Services ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢:
 *   c.var.services ã§å…¨ Service ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã€‚
 *   ãƒªã‚¯ã‚¨ã‚¹ãƒˆã”ã¨ã« 1 ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚»ãƒƒãƒˆã€‚æ¯å› new ã—ãªã„ã€‚
 */
export const servicesMiddleware = createMiddleware(async (c, next) => {
  // å®Ÿéš›ã® db åˆæœŸåŒ–ã¯ env ã‹ã‚‰å–å¾—
  // const db = drizzle(c.env.DB);
  const db = {} as any; // placeholder
  c.set("services", createServices(db));
  await next();
});

// --- apps/api/src/routes/sessions.ts (åˆ©ç”¨ä¾‹) ---
// import { Hono } from 'hono';
// const app = new Hono();
//
// app.post('/sessions/:id/end', async (c) => {
//   const { session, streak } = c.var.services;
//   const userId = c.var.requestContext.userId;
//   const sessionId = c.req.param('id');
//   const body = await c.req.json();
//
//   const result = await session.endSession(userId, sessionId, body);
//   return c.json(result, 200);
// });

// ============================================================
// ä¿®æ­£ #7: 1 åˆ†æœªæº€ã‚»ãƒƒã‚·ãƒ§ãƒ³ç ´æ£„ API (DELETE /sessions/:id)
// ============================================================

// --- SessionService.discardSession ---
// (SessionService ã‚¯ãƒ©ã‚¹å†…ãƒ¡ã‚½ãƒƒãƒ‰)

interface DiscardResult {
  discardedSessionId: string;
  dailyLog: DailyLogResponse | null;
  streak: StreakUpdateResponse;
}

async function discardSession(
  this: { db: DB },
  userId: string,
  sessionId: string,
  timezone: string
): Promise<DiscardResult> {
  const db = this.db;

  return await db.transaction(async (tx) => {
    // 1. ã‚»ãƒƒã‚·ãƒ§ãƒ³å–å¾— & æ‰€æœ‰è€…ãƒã‚§ãƒƒã‚¯
    const [session] = await tx
      .select()
      .from(readingSessions)
      .where(
        and(
          eq(readingSessions.id, sessionId),
          eq(readingSessions.userId, userId)
        )
      );
    if (!session) throw new NotFoundError("Session not found");

    // 2. ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚»ãƒƒã‚·ãƒ§ãƒ³ãªã‚‰å³çµ‚äº†æ‰±ã„ã«ã—ã¦ç ´æ£„
    //    å®Œäº†æ¸ˆã¿ã§ã‚‚ç ´æ£„å¯èƒ½ï¼ˆ1åˆ†æœªæº€ã®èª¤æ“ä½œã‚»ãƒƒã‚·ãƒ§ãƒ³æƒ³å®šï¼‰

    // 3. é–¢é€£ã™ã‚‹ session_pauses ã‚’å‰Šé™¤
    await tx
      .delete(sessionPauses)
      .where(eq(sessionPauses.sessionId, sessionId));

    // 4. ã‚»ãƒƒã‚·ãƒ§ãƒ³æœ¬ä½“ã‚’å‰Šé™¤
    await tx
      .delete(readingSessions)
      .where(eq(readingSessions.id, sessionId));

    // 5. daily_reading_logs ã‚’å†é›†è¨ˆ
    const localDate = session.localDate;
    const remainingSessions = await tx
      .select({
        total: sql<number>`COALESCE(SUM(duration_sec), 0)`,
        count: sql<number>`COUNT(*)`,
      })
      .from(readingSessions)
      .where(
        and(
          eq(readingSessions.userId, userId),
          eq(readingSessions.localDate, localDate)
        )
      );

    const { total, count } = remainingSessions[0];
    let dailyLog: DailyLogResponse | null = null;

    if (count > 0) {
      await tx
        .update(dailyReadingLogs)
        .set({
          totalSeconds: total,
          sessionCount: count,
          updatedAt: new Date().toISOString(),
        })
        .where(
          and(
            eq(dailyReadingLogs.userId, userId),
            eq(dailyReadingLogs.logDate, localDate)
          )
        );
      dailyLog = { logDate: localDate, totalSeconds: total, sessionCount: count };
    } else {
      // ãã®æ—¥ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ãŒ 0 ä»¶ã«ãªã£ãŸ â†’ daily_log å‰Šé™¤
      await tx
        .delete(dailyReadingLogs)
        .where(
          and(
            eq(dailyReadingLogs.userId, userId),
            eq(dailyReadingLogs.logDate, localDate)
          )
        );
    }

    // 6. ã‚¹ãƒˆãƒªãƒ¼ã‚¯å†è¨ˆç®—ï¼ˆã‚»ãƒƒã‚·ãƒ§ãƒ³å‰Šé™¤ã«ã‚ˆã‚Šé€”åˆ‡ã‚Œã‚‹å¯èƒ½æ€§ï¼‰
    const streak = await recalculateStreak(tx, userId, timezone);

    return {
      discardedSessionId: sessionId,
      dailyLog,
      streak,
    };
  });
}

// ============================================================
// ä¿®æ­£ #8: æ›¸ç±ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥æˆ¦ç•¥
// ============================================================

// --- packages/shared/src/constants/cache.ts ---
export const BOOK_CACHE_REFRESH_DAYS = 30;

// --- BookService å†… ---

async function getBookWithCacheRefresh(
  this: { db: DB },
  bookId: string
): Promise<Book> {
  const db = this.db;
  const [book] = await db
    .select()
    .from(books)
    .where(eq(books.id, bookId));

  if (!book) throw new NotFoundError("Book not found");

  // fetchedAt ãŒ BOOK_CACHE_REFRESH_DAYS è¶…é â†’ ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥
  if (book.isbn && book.fetchedAt) {
    const fetchedAt = new Date(book.fetchedAt);
    const daysSinceFetch =
      (Date.now() - fetchedAt.getTime()) / (1000 * 60 * 60 * 24);

    if (daysSinceFetch > BOOK_CACHE_REFRESH_DAYS) {
      // waitUntil ã§éåŒæœŸå®Ÿè¡Œï¼ˆãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ãªã„ï¼‰
      // c.executionCtx.waitUntil(refreshBookCache(book.isbn, bookId));
      scheduleBookRefresh(book.isbn, bookId);
    }
  }

  return book;
}

async function refreshBookCache(isbn: string, bookId: string) {
  try {
    // Google Books API â†’ OpenBD ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯é †ã§å†å–å¾—
    const fresh = await fetchBookByISBN(isbn);
    if (!fresh) return;

    await db
      .update(books)
      .set({
        title: fresh.title,
        author: fresh.author,
        coverUrl: fresh.coverUrl,
        description: fresh.description,
        fetchedAt: new Date().toISOString(),
      })
      .where(eq(books.id, bookId));
  } catch {
    // ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥å¤±æ•—ã¯ç„¡è¦–ï¼ˆæ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã‚’ç¶­æŒï¼‰
    console.error(`Book cache refresh failed: isbn=${isbn}`);
  }
}

// ============================================================
// ä¿®æ­£ #9: ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ sync æ™‚ã®éå»æ—¥ã‚»ãƒƒã‚·ãƒ§ãƒ³å¯¾å¿œ
// ============================================================

// --- SessionService.endSession å†… ---

async function endSession(
  this: { db: DB },
  userId: string,
  sessionId: string,
  body: EndSessionInput,
  timezone: string
): Promise<SessionEndResponse> {
  const db = this.db;

  return await db.transaction(async (tx) => {
    // 1. ã‚»ãƒƒã‚·ãƒ§ãƒ³å–å¾—
    const [session] = await tx
      .select()
      .from(readingSessions)
      .where(
        and(
          eq(readingSessions.id, sessionId),
          eq(readingSessions.userId, userId),
          eq(readingSessions.isActive, 1)
        )
      );
    if (!session) throw new NotFoundError("Active session not found");

    // 2. ä¸€æ™‚åœæ­¢ä¸­ãªã‚‰è‡ªå‹•å†é–‹
    if (session.isPaused) {
      await autoResumePause(tx, sessionId);
    }

    const endedAt = new Date().toISOString();
    const durationSec =
      Math.floor(
        (new Date(endedAt).getTime() - new Date(session.startedAt).getTime()) /
          1000
      ) - (session.pausedTotalSec ?? 0);

    // 3. ã‚»ãƒƒã‚·ãƒ§ãƒ³æ›´æ–°
    await tx.update(readingSessions).set({
      isActive: 0,
      endedAt,
      durationSec: Math.max(0, durationSec),
      pageStart: body.pageStart ?? null,
      pageEnd: body.pageEnd ?? null,
      memo: body.memo ?? null,
      updatedAt: endedAt,
    }).where(eq(readingSessions.id, sessionId));

    // 4. user_books.current_page æ›´æ–°
    if (body.pageEnd != null) {
      await updateCurrentPage(tx, userId, session.bookId, body.pageEnd);
    }

    // 5. daily_reading_logs UPSERT
    const localDate = session.localDate;
    const today = getUserToday(timezone);

    await upsertDailyLog(tx, userId, localDate, durationSec);

    // ğŸ”„ v1.1 (#9): localDate â‰  today â†’ ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ sync ã®ã‚±ãƒ¼ã‚¹
    //   å·®åˆ†æ›´æ–°ã§ã¯ä¸æ­£ç¢ºã«ãªã‚‹ãŸã‚ã€ãƒ•ãƒ«å†è¨ˆç®—ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
    let streak: StreakUpdateResponse;
    if (localDate !== today) {
      // éå»æ—¥ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ â†’ é¡åŠãƒ•ãƒ«å†è¨ˆç®—
      streak = await recalculateStreak(tx, userId, timezone);
    } else {
      // å½“æ—¥ã‚»ãƒƒã‚·ãƒ§ãƒ³ â†’ å·®åˆ†æ›´æ–°ï¼ˆé«˜é€Ÿï¼‰
      streak = await incrementalStreakUpdate(tx, userId, timezone, localDate);
    }

    const wallClockSec = durationSec + (session.pausedTotalSec ?? 0);

    return {
      session: {
        id: sessionId,
        bookId: session.bookId,
        sessionType: session.sessionType as SessionType,
        durationSec: Math.max(0, durationSec),
        pausedTotalSec: session.pausedTotalSec ?? 0,
        wallClockSec,
        pageStart: body.pageStart ?? null,
        pageEnd: body.pageEnd ?? null,
        memo: body.memo ?? null,
        localDate,
        startedAt: session.startedAt,
        endedAt,
      },
      streak,
      dailyLog: await getDailyLog(tx, userId, localDate),
    };
  });
}

// ============================================================
// ä¿®æ­£ #10: StatsService ã®ä¸¦åˆ—åŒ– (Promise.all)
// ============================================================

// --- StatsService.getSummary ---

interface StatsSummary {
  totalReadingSeconds: number;
  totalSessions: number;
  totalBooksFinished: number;
  totalBooksInProgress: number;
  totalPages: number;
  averageSessionMinutes: number;
}

async function getSummary(
  this: { db: DB },
  userId: string
): Promise<StatsSummary> {
  const db = this.db;

  // ğŸ”„ v1.1: å…¨ 6 ã‚¯ã‚¨ãƒªã‚’ Promise.all ã§ä¸¦åˆ—å®Ÿè¡Œ
  // v1.0 ã§ã¯ totalBooksFinished ã ã‘åˆ¥ã§ await ã—ã¦ã„ãŸ
  const [
    sessionStats,
    finishedCount,
    readingCount,
    totalPages,
  ] = await Promise.all([
    // 1. ã‚»ãƒƒã‚·ãƒ§ãƒ³é›†è¨ˆï¼ˆæ™‚é–“ + å›æ•°ã‚’ 1 ã‚¯ã‚¨ãƒªã§ï¼‰
    db
      .select({
        totalSec: sql<number>`COALESCE(SUM(duration_sec), 0)`,
        totalCount: sql<number>`COUNT(*)`,
      })
      .from(readingSessions)
      .where(
        and(
          eq(readingSessions.userId, userId),
          eq(readingSessions.isActive, 0)
        )
      )
      .then((r) => r[0]),

    // 2. èª­äº†å†Šæ•°
    db
      .select({ count: sql<number>`COUNT(*)` })
      .from(userBooks)
      .where(
        and(
          eq(userBooks.userId, userId),
          eq(userBooks.status, "FINISHED")
        )
      )
      .then((r) => r[0].count),

    // 3. èª­æ›¸ä¸­å†Šæ•°
    db
      .select({ count: sql<number>`COUNT(*)` })
      .from(userBooks)
      .where(
        and(
          eq(userBooks.userId, userId),
          eq(userBooks.status, "READING")
        )
      )
      .then((r) => r[0].count),

    // 4. ç·ãƒšãƒ¼ã‚¸æ•°
    db
      .select({
        total: sql<number>`COALESCE(SUM(
          CASE WHEN page_end IS NOT NULL AND page_start IS NOT NULL
               THEN page_end - page_start
               ELSE 0 END
        ), 0)`,
      })
      .from(readingSessions)
      .where(
        and(
          eq(readingSessions.userId, userId),
          eq(readingSessions.isActive, 0)
        )
      )
      .then((r) => r[0].total),
  ]);

  const avgMin =
    sessionStats.totalCount > 0
      ? Math.round(sessionStats.totalSec / sessionStats.totalCount / 60)
      : 0;

  return {
    totalReadingSeconds: sessionStats.totalSec,
    totalSessions: sessionStats.totalCount,
    totalBooksFinished: finishedCount,
    totalBooksInProgress: readingCount,
    totalPages: totalPages,
    averageSessionMinutes: avgMin,
  };
}

// ============================================================
// ä¿®æ­£ #11: ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³è¨­è¨ˆ
// ============================================================

// ä»¥ä¸‹ã® 3 æ“ä½œã¯å¿…ãš db.transaction() ã§åŒ…ã‚€:
//
// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ æ“ä½œ                 â”‚ ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³å†…ã§è¡Œã†å‡¦ç†            â”‚
// â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
// â”‚ endSession           â”‚ ã‚»ãƒƒã‚·ãƒ§ãƒ³æ›´æ–° â†’ user_books æ›´æ–° â†’     â”‚
// â”‚                      â”‚ daily_log UPSERT â†’ ã‚¹ãƒˆãƒªãƒ¼ã‚¯æ›´æ–°      â”‚
// â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
// â”‚ createManualSession  â”‚ ã‚»ãƒƒã‚·ãƒ§ãƒ³ INSERT â†’ daily_log å†é›†è¨ˆ    â”‚
// â”‚                      â”‚ â†’ ã‚¹ãƒˆãƒªãƒ¼ã‚¯å†è¨ˆç®—                     â”‚
// â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
// â”‚ discardSession       â”‚ pauses å‰Šé™¤ â†’ ã‚»ãƒƒã‚·ãƒ§ãƒ³å‰Šé™¤ â†’         â”‚
// â”‚                      â”‚ daily_log å†é›†è¨ˆ â†’ ã‚¹ãƒˆãƒªãƒ¼ã‚¯å†è¨ˆç®—     â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
//
// ä¸Šè¨˜ã® endSession / discardSession ã¯æ—¢ã«ã‚³ãƒ¼ãƒ‰å†…ã§
// db.transaction() ã‚’ä½¿ç”¨ã€‚createManualSession ã‚‚åŒæ§˜:

async function createManualSession(
  this: { db: DB },
  userId: string,
  input: ManualSessionInput,
  timezone: string
): Promise<SessionEndResponse> {
  const db = this.db;

  return await db.transaction(async (tx) => {
    const id = crypto.randomUUID();
    const durationSec = input.durationMin * 60;
    const localDate = input.date;

    // æ—¥ä»˜ç¯„å›²ãƒã‚§ãƒƒã‚¯ï¼ˆéå» 7 æ—¥ä»¥å†…ï¼‰
    const today = getUserToday(timezone);
    const daysDiff = daysBetween(localDate, today);
    if (daysDiff < 0 || daysDiff > 7) {
      throw new ValidationError("MANUAL_LOG_DATE_RANGE", "éå»7æ—¥ä»¥å†…ã®æ—¥ä»˜ã‚’æŒ‡å®šã—ã¦ãã ã•ã„");
    }

    // 1. ã‚»ãƒƒã‚·ãƒ§ãƒ³ INSERT
    await tx.insert(readingSessions).values({
      id,
      userId,
      bookId: input.bookId,
      sessionType: "MANUAL",
      durationSec,
      localDate,
      startedAt: `${localDate}T00:00:00Z`,
      endedAt: `${localDate}T00:00:00Z`,
      isActive: 0,
      pageStart: input.pageStart ?? null,
      pageEnd: input.pageEnd ?? null,
      memo: input.memo ?? null,
    });

    // 2. user_books.current_page æ›´æ–°
    if (input.pageEnd != null) {
      await updateCurrentPage(tx, userId, input.bookId, input.pageEnd);
    }

    // 3. daily_reading_logs â€” ã‚ã¨ã‹ã‚‰è¨˜éŒ²ã¯å…¨ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‹ã‚‰å†é›†è¨ˆ
    await recalculateDailyLog(tx, userId, localDate);

    // 4. ã‚¹ãƒˆãƒªãƒ¼ã‚¯å†è¨ˆç®—ï¼ˆéå»æ—¥ã®ãŸã‚å¿…ãšãƒ•ãƒ«å†è¨ˆç®—ï¼‰
    const streak = await recalculateStreak(tx, userId, timezone);

    return {
      session: {
        id,
        bookId: input.bookId,
        sessionType: "MANUAL" as SessionType,
        durationSec,
        pausedTotalSec: 0,
        wallClockSec: durationSec,
        pageStart: input.pageStart ?? null,
        pageEnd: input.pageEnd ?? null,
        memo: input.memo ?? null,
        localDate,
        startedAt: `${localDate}T00:00:00Z`,
        endedAt: `${localDate}T00:00:00Z`,
      },
      streak,
      dailyLog: (await getDailyLog(tx, userId, localDate))!,
    };
  });
}

// ============================================================
// ä¿®æ­£ #12: Clerk èªè¨¼ã‚’ JWKS (jose) ã«å¤‰æ›´
// ============================================================

// --- apps/api/src/middleware/auth.ts ---
import { createMiddleware } from "hono/factory";
import { createRemoteJWKSet, jwtVerify } from "jose";

// JWKS ã¯ä¸€åº¦å–å¾—ã—ãŸã‚‰ãƒ¡ãƒ¢ãƒªã«ã‚­ãƒ£ãƒƒã‚·ãƒ¥
let jwks: ReturnType<typeof createRemoteJWKSet> | null = null;

function getJWKS(clerkDomain: string) {
  if (!jwks) {
    jwks = createRemoteJWKSet(
      new URL(`https://${clerkDomain}/.well-known/jwks.json`)
    );
  }
  return jwks;
}

export const authMiddleware = createMiddleware(async (c, next) => {
  const authHeader = c.req.header("Authorization");
  if (!authHeader?.startsWith("Bearer ")) {
    return c.json(
      { error: { code: "UNAUTHORIZED", message: "èªè¨¼ãŒå¿…è¦ã§ã™" } },
      401
    );
  }

  const token = authHeader.slice(7);

  try {
    const keySet = getJWKS(c.env.CLERK_DOMAIN);
    const { payload } = await jwtVerify(token, keySet, {
      issuer: `https://${c.env.CLERK_DOMAIN}`,
    });

    const timezone = c.req.header("X-Timezone") || "Asia/Tokyo";

    c.set("requestContext", {
      userId: payload.sub as string,
      timezone,
    });

    await next();
  } catch {
    return c.json(
      { error: { code: "UNAUTHORIZED", message: "ãƒˆãƒ¼ã‚¯ãƒ³ãŒç„¡åŠ¹ã§ã™" } },
      401
    );
  }
});

// â”€â”€ æ—§æ–¹å¼ã¨ã®æ¯”è¼ƒ â”€â”€
// | æ–¹å¼                | å‹•ä½œ                          | Edge é©æ€§ |
// |---------------------|-------------------------------|-----------|
// | verifyToken(secret) | Clerk API ã«é€šä¿¡ã—ã¦æ¤œè¨¼       | âŒ å¤–éƒ¨é€šä¿¡  |
// | JWKS (jose)         | å…¬é–‹éµã‚­ãƒ£ãƒƒã‚·ãƒ¥ â†’ ãƒ­ãƒ¼ã‚«ãƒ«æ¤œè¨¼ | âœ… é«˜é€Ÿ    |
//
// ä¾å­˜ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸: joseï¼ˆWeb Crypto API ãƒ™ãƒ¼ã‚¹ã€‚Workers ã§ãƒã‚¤ãƒ†ã‚£ãƒ–å‹•ä½œï¼‰


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ï¼ˆä¸Šè¨˜ã‚³ãƒ¼ãƒ‰ã‹ã‚‰å‚ç…§ï¼‰
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function getUserToday(timezone: string): string {
  return new Date().toLocaleDateString("sv-SE", { timeZone: timezone });
}

function daysBetween(dateA: string, dateB: string): number {
  const a = new Date(dateA).getTime();
  const b = new Date(dateB).getTime();
  return Math.round((b - a) / (1000 * 60 * 60 * 24));
}

async function upsertDailyLog(
  tx: any, userId: string, logDate: string, addSec: number
) {
  await tx
    .insert(dailyReadingLogs)
    .values({
      id: crypto.randomUUID(),
      userId,
      logDate,
      totalSeconds: addSec,
      sessionCount: 1,
    })
    .onConflictDoUpdate({
      target: [dailyReadingLogs.userId, dailyReadingLogs.logDate],
      set: {
        totalSeconds: sql`total_seconds + ${addSec}`,
        sessionCount: sql`session_count + 1`,
        updatedAt: new Date().toISOString(),
      },
    });
}

async function recalculateDailyLog(
  tx: any, userId: string, logDate: string
) {
  const [result] = await tx
    .select({
      total: sql<number>`COALESCE(SUM(duration_sec), 0)`,
      count: sql<number>`COUNT(*)`,
    })
    .from(readingSessions)
    .where(
      and(
        eq(readingSessions.userId, userId),
        eq(readingSessions.localDate, logDate),
        eq(readingSessions.isActive, 0)
      )
    );

  if (result.count > 0) {
    await tx
      .insert(dailyReadingLogs)
      .values({
        id: crypto.randomUUID(),
        userId,
        logDate,
        totalSeconds: result.total,
        sessionCount: result.count,
      })
      .onConflictDoUpdate({
        target: [dailyReadingLogs.userId, dailyReadingLogs.logDate],
        set: {
          totalSeconds: result.total,
          sessionCount: result.count,
          updatedAt: new Date().toISOString(),
        },
      });
  } else {
    await tx
      .delete(dailyReadingLogs)
      .where(
        and(
          eq(dailyReadingLogs.userId, userId),
          eq(dailyReadingLogs.logDate, logDate)
        )
      );
  }
}

// å‹ã‚„ãƒ†ãƒ¼ãƒ–ãƒ«å‚ç…§ã®ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ï¼ˆå®Ÿéš›ã¯ schema.ts ã‹ã‚‰ã‚¤ãƒ³ãƒãƒ¼ãƒˆï¼‰
declare const readingSessions: any;
declare const sessionPauses: any;
declare const dailyReadingLogs: any;
declare const userBooks: any;
declare const streakFreezes: any;
declare function recalculateStreak(tx: any, userId: string, tz: string): Promise<StreakUpdateResponse>;
declare function incrementalStreakUpdate(tx: any, userId: string, tz: string, date: string): Promise<StreakUpdateResponse>;
declare function updateCurrentPage(tx: any, userId: string, bookId: string, page: number): Promise<void>;
declare function getDailyLog(tx: any, userId: string, date: string): Promise<DailyLogResponse>;
declare function autoResumePause(tx: any, sessionId: string): Promise<void>;
declare function fetchBookByISBN(isbn: string): Promise<any>;
declare function scheduleBookRefresh(isbn: string, bookId: string): void;
declare class NotFoundError extends Error { constructor(msg: string); }
declare class ValidationError extends Error { constructor(code: string, msg: string); }
declare type Book = any;
declare type EndSessionInput = any;
declare type ManualSessionInput = { bookId: string; date: string; durationMin: number; pageStart?: number; pageEnd?: number; memo?: string; };